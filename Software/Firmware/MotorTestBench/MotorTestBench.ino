// Motor Test Bench V1.0
// Developer: Alan Carvalho
// Date: 03/04/2024

#include "HX711.h"    // Library to control the HX711 module

// Motor control pins
#define MOTOR_ENA 5
#define MOTOR_IN1 6
#define MOTOR_IN2 7

// HX711 pins
#define LOADCELL_SCK 10
#define LOADCELL_DT 11

// Optical switch pin
#define OPTICAL_SWITCH 3

// Bench parameters
#define PWM_INCREMENT 1           // PWM increment at each step
#define ARM_LENGTH 0.035          // Lever arm length (m)
#define ENCODER_POINTS 20.0       // Number of windows in the encoder disk
#define MAX_PULSES 100            // Number of pulses to restart the counting
#define MAX_VOLTAGE 12.0          // Power supply voltage (V)


HX711 loadCell;   // HX711 library object

unsigned int pwm = 75;            // PWM applied to the motor
float voltage = 0;                // Voltage applied to the motor (V)
float current= 0;                 // Current consumed by the motor (A)
float mass = 0;                   // Mass on the load cell (g)
float torque = 0;                 // Torque generated by the motor (mN.m)
float speed = 0;                  // Motor shaft speed (RPM)
volatile int pulseCount = 0;      // Encoder pulse count
unsigned long currentTime = 0;    // Current time on speed calculation (ms)
unsigned long initialTime = 0;    // Initial time on speed calculation (ms)
const long stepTime = 1000;       // Duration of each PWM step
unsigned long lastStep = 0;       // Time when the last PWM step happened


void setup() 
{
  Serial.begin(115200);   // Open the serial port

  // Configure pins
  pinMode(MOTOR_ENA, OUTPUT);
  pinMode(MOTOR_IN1, OUTPUT);
  pinMode(MOTOR_IN2, OUTPUT);
  pinMode(OPTICAL_SWITCH, INPUT_PULLUP);

  // Set pins starting state
  digitalWrite(MOTOR_IN1, HIGH);
  digitalWrite(MOTOR_IN2, LOW);
  analogWrite(MOTOR_ENA, pwm);

  // Configure the HX711 sensor
  loadCell.begin(LOADCELL_DT, LOADCELL_SCK);
  loadCell.set_scale(440);
  loadCell.tare();

  // Configure the interrupt to detect encoder pulses
  attachInterrupt(digitalPinToInterrupt(OPTICAL_SWITCH), countPulse, RISING);

  // Print table header
  Serial.println("Voltage (V) Torque (mN.m) Speed(RPM)");

  // Wait some time before starting the test
  delay(10000);
}


void loop() 
{
  if ((millis() - lastStep) > stepTime) stepPWM();

  // Get all the necessary data
  getVoltage();
  getTorque();
  getSpeed();

  // Print the collected data on the serial port
  printData();

  delay(50);
}


void stepPWM()
{
  pwm = pwm + PWM_INCREMENT;
  
  if (pwm > 255)
  {
    pwm = 75;
    analogWrite(MOTOR_ENA, pwm);
    Serial.println("");
    delay(10000);
  }

  else analogWrite(MOTOR_ENA, pwm);
  
  lastStep = millis();
}

void getVoltage()
{
  voltage = (MAX_VOLTAGE / 255.0) * pwm;
}

void getTorque()
{
  mass = loadCell.get_units();
  torque = 9.81 * mass * ARM_LENGTH;
  if (torque < 0) torque = 0;
}

void getSpeed()
{
  currentTime = millis() - initialTime;
  speed = 60000 * ((pulseCount / ENCODER_POINTS) / currentTime);
  if (speed< 0) speed = 0;

  if(pulseCount > MAX_PULSES)
  {
    pulseCount = 0;
    initialTime = millis();
  }
}

void countPulse()
{
  pulseCount++;
}

void printData()
{
  Serial.print(voltage);
  Serial.print("  ");

  Serial.print(torque);
  Serial.print("  ");

  Serial.print(speed);
  Serial.print("  ");

  Serial.println("");
}