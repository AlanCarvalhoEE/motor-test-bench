// Motor Test Bench V1.0
// Developer: Alan Carvalho
// Date: 03/04/2024

#include <Stepper.h>  // Library to control the stepper motor
#include "HX711.h"    // Library to control the HX711 module

// HX711 pins
#define LOADCELL_SCK 10
#define LOADCELL_DT 11

// Optical switch pin
#define OPTICAL_SWITCH 3

// Bench parameters
#define STEPPER_SPR 2048          // Number of steps per revolution of the stepper
#define STEPPER_SPEED 1           // Stepper motor speed
#define STEPPER_STEPS 15          // Number of steps per measurement
#define ARM_LENGTH 0.035          // Lever arm length (m)
#define ENCODER_POINTS 20.0       // Number of windows in the encoder disk
#define MAX_PULSES 100            // Number of pulses to restart the counting

Stepper stepper(STEPPER_SPR, 4, 5, 6, 7);    // Stepper library object
HX711 loadCell;                              // HX711 library object

bool running = true;             // Indicates the test is running
float mass = 0;                   // Mass on the load cell (g)
float torque = 0;                 // Torque generated by the motor (mN.m)
float speed = 0;                  // Motor shaft speed (RPM)
volatile int pulseCount = 0;      // Encoder pulse count
unsigned long currentTime = 0;    // Current time on speed calculation (ms)
unsigned long initialTime = 0;    // Initial time on speed calculation (ms)
const long readingInterval = 25;  // Interval between readings (ms)
unsigned long lastReading = 0;    // Time of the last reading (ms)
const long stepInterval = 100;    // Interval between stepper steps (ms)
unsigned long lastStep = 0;       // Time of the last step (ms)


void setup() 
{
  Serial.begin(115200);   // Open the serial port

  // Configure pins
  pinMode(OPTICAL_SWITCH, INPUT_PULLUP);

  // Configure stepper speed
  stepper.setSpeed(STEPPER_SPEED);

  // Configure the HX711 sensor
  loadCell.begin(LOADCELL_DT, LOADCELL_SCK);
  loadCell.set_scale(440);
  loadCell.tare();

  // Configure the interrupt to detect encoder pulses
  attachInterrupt(digitalPinToInterrupt(OPTICAL_SWITCH), countPulse, RISING);
}


void loop() 
{
  if(Serial.available() > 0)
  {
    String command = Serial.readString();

    if(command.equals("START"))
    {
      running = true;
      Serial.println("Speed (RPM)|Torque (mN.m)");
    }

    else if (command.equals("STOP"))
    {
      running = false;
      Serial.println("");
    }

    else if (command.equals("+") && !running) stepper.step(-STEPPER_SPR);
    else if (command.equals("-") && !running) stepper.step(STEPPER_SPR);
  }

  if (running)
  {
    if((millis() - lastReading) > readingInterval)
    {
      // Get all the necessary data
      getSpeed();
      getTorque();

      // Print the collected data on the serial port
      printData();

      lastReading = millis();
    }

    if((millis() - lastStep) > stepInterval)
    {
      stepper.step(STEPPER_STEPS);
      lastStep = millis();
    }
  }
}


void getTorque()
{
  mass = loadCell.get_units();
  torque = 9.81 * mass * ARM_LENGTH;
  if (torque < 0) torque = 0;
}

void getSpeed()
{
  currentTime = millis() - initialTime;
  speed = 60000 * ((pulseCount / ENCODER_POINTS) / currentTime);
  if (speed< 0) speed = 0;

  if(pulseCount > MAX_PULSES)
  {
    pulseCount = 0;
    initialTime = millis();
  }
}

void countPulse()
{
  pulseCount++;
}

void printData()
{
  Serial.print(speed);
  Serial.print("|");
  Serial.print(torque);
  Serial.println("");
}